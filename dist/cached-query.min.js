(()=>{"use strict";var n={d:(e,o)=>{for(var i in o)n.o(o,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:o[i]})},o:(n,e)=>Object.prototype.hasOwnProperty.call(n,e),r:n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},e={};n.r(e),n.d(e,{clearQueries:()=>i,cquery_cache:()=>o,fetchJsonEngine:()=>r,invalidateQuery:()=>a,invokeSubscriptions:()=>l,mockEngine:()=>c,mockQuery:()=>s,preparedQuery:()=>t,replaceQuery:()=>u,replaceQueryDefaultEngine:()=>d,resetContext:()=>k,subscribeQuery:()=>g,useQuery:()=>f});const o={};function i(){for(var n in o)delete o[n]}function t(n,e,i={},t={}){if(n in o){let i=o[n];return void(i.url!==e&&console.warn(`ignore the url: a query already exists with different url ${i.url}, you try to prepare for ${e}`))}let a={callbacks:[],data:null,error:null,key:n,isLoading:!1,response:null,mock:!1,url:e,request_options:i,invalidationStop:null,invalidationInterval:null,invalidationCounter:0,postponeInvalidation:t.postponeInvalidation||!0,engine:t.engine||null,delayedLoading:!0};"delayedLoading"in t&&(a.delayedLoading=t.delayedLoading),"mock"in t&&null!==t.mock&&I(a,t),"interval"in t&&null!==t.interval&&L(a,t.interval),o[n]=a}function a(n){m(n);const e=o[n];null===e.data&&!0===e.isLoading||y(e,!0)}function l(n,e,o,i){if(n.invalidationCounter-=1,0===n.invalidationCounter||!1===n.postponeInvalidation){n.isLoading=!1,n.data=e,n.error=o,n.response=i;for(const e in n.callbacks)v(n.callbacks[e],n)}}function r(n){let e=null;fetch(n.url,n.request_options).then((n=>(e=n,n.json()))).then((o=>{l(n,o,null,e)})).catch((o=>{l(n,null,o,e)}))}function c(n){n.isLoading=n.mockIsLoading,l(n,n.mockData,n.mockError,n.mockResponse)}function s(n,e,i=!1,t=null,a=null){m(n);const l=o[n];l.mock=!0,l.mockData=e,l.mockIsLoading=i,l.mockError=t,l.mockResponse=a}function u(n,e,i={},t={}){m(n);let a=o[n];a.url=e,a.request_options=i,a.engine=t.engine||p,"mock"in t?I(a,t):function(n){n.mock=!1,n.mockData=null,n.mockIsLoading=null,n.mockError=null,n.mockResponse=null}(a),"interval"in t?L(a,t.interval):h(a)}function d(n){p=n}function k(){p=r,i()}function f(n,e){m(n);const i=o[n];null===i.data&&!1===i.isLoading&&null===i.error?(i.callbacks.push(e),y(i)):(i.callbacks.push(e),v(e,i))}function g(n,e){m(n);const i=o[n];null===i.data&&!1===i.isLoading&&null===i.error?i.callbacks.push(e):(i.callbacks.push(e),v(e,i))}let p=r;function m(n){if(!(n in o))throw`The query '${n}' does not exists - prepared queries : [${Object.keys(o)}]`}function y(n,e=!1){if(n.invalidationCounter+=1,!0!==n.mock){n.data=null,n.isLoading=!0,n.response=null,n.error=null;for(const e in n.callbacks)v(n.callbacks[e],n)}if(!0===n.mock&&!0===n.mockIsLoading){n.isLoading=n.mockIsLoading;for(const e in n.callbacks)b(n.callbacks[e],n)}else!0===n.mock?c(n):null!==n.engine?n.engine(n):p(n)}function v(n,e){let o=new _;n(e.data,e.isLoading,e.error,e.response,o),!0===o.triggered&&S(e,n)}function b(n,e){let o=new _;n(e.mockData,e.mockIsLoading,e.mockError,e.mockResponse,o),!0===o.triggered&&S(e,n)}function L(n,e){h(n),n.invalidationStop=setTimeout((()=>L(n,e)),1e3*e),!1!==n.isLoading&&!1!==n.delayedLoading||y(n)}function h(n){n.invalidationStop&&clearTimeout(n.invalidationStop)}function I(n,e){n.mock=!0,n.mockData=e.mock.data,n.mockIsLoading=e.mock.isLoading,n.mockError=e.mock.error,n.mockResponse=e.mock.response}function S(n,e){const o=n.callbacks.indexOf(e);-1!==o&&n.callbacks.splice(o,1)}function _(){this.triggered=!1,this.set=()=>{this.triggered=!0}}var w=window;for(var E in e)w[E]=e[E];e.__esModule&&Object.defineProperty(w,"__esModule",{value:!0})})();